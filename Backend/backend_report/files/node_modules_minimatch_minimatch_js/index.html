<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules\minimatch\minimatch.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules\minimatch\minimatch.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.57</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">947</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">119.42</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.22</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return require(&#039;path&#039;) } catch (e) {}}()) || {
  sep: &#039;/&#039;
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require(&#039;brace-expansion&#039;)

var plTypes = {
  &#039;!&#039;: { open: &#039;(?:(?!(?:&#039;, close: &#039;))[^/]*?)&#039;},
  &#039;?&#039;: { open: &#039;(?:&#039;, close: &#039;)?&#039; },
  &#039;+&#039;: { open: &#039;(?:&#039;, close: &#039;)+&#039; },
  &#039;*&#039;: { open: &#039;(?:&#039;, close: &#039;)*&#039; },
  &#039;@&#039;: { open: &#039;(?:&#039;, close: &#039;)&#039; }
}

// any single thing other than /
// don&#039;t need to escape / when using new RegExp()
var qmark = &#039;[^/]&#039;

// * =&gt; any number of characters
var star = qmark + &#039;*?&#039;

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = &#039;(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?&#039;

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = &#039;(?:(?!(?:\\\/|^)\\.).)*?&#039;

// characters that need to be escaped in RegExp.
var reSpecials = charSet(&#039;().*{}+?[]^$\\!&#039;)

// &quot;abc&quot; -&gt; { a:true, b:true, c:true }
function charSet (s) {
  return s.split(&#039;&#039;).reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== &#039;object&#039; || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape &amp;&amp; path.sep !== &#039;/&#039;) {
    pattern = pattern.split(path.sep).join(&#039;/&#039;)
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of &quot;**&quot;, which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --&gt; regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn&#039;t compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i &lt; l &amp;&amp; pattern.charAt(i) === &#039;!&#039;
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -&gt; abd acd
// a{b,}c -&gt; abc ac
// a{0..3}d -&gt; a0d a1d a2d a3d
// a{b,c{d,e}f}g -&gt; abg acdfg acefg
// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -&gt; a{2..}b
// a{b}c -&gt; a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === &#039;undefined&#039;
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li &lt;https://github.com/yetingli&gt; for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== &#039;string&#039;) {
    throw new TypeError(&#039;invalid pattern&#039;)
  }

  if (pattern.length &gt; MAX_PATTERN_LENGTH) {
    throw new TypeError(&#039;pattern is too long&#039;)
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain &quot;/&quot; in it
// so we&#039;re going to return a 2d array, where each entry is the full
// pattern, split on &#039;/&#039;, and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === &#039;**&#039;) {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = &#039;*&#039;
  }
  if (pattern === &#039;&#039;) return &#039;&#039;

  var re = &#039;&#039;
  var hasMagic = !!options.nocase
  var escaping = false
  // ? =&gt; one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn&#039;t start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === &#039;.&#039; ? &#039;&#039; // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? &#039;(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))&#039;
  : &#039;(?!\\.)&#039;
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn&#039;t consumed by this pass.
      switch (stateChar) {
        case &#039;*&#039;:
          re += star
          hasMagic = true
        break
        case &#039;?&#039;:
          re += qmark
          hasMagic = true
        break
        default:
          re += &#039;\\&#039; + stateChar
        break
      }
      self.debug(&#039;clearStateChar %j %j&#039;, stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))
    ; i++) {
    this.debug(&#039;%s\t%s %s %j&#039;, pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping &amp;&amp; reSpecials[c]) {
      re += &#039;\\&#039; + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case &#039;/&#039;: {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case &#039;\\&#039;:
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the &quot;extglob&quot; stuff.
      case &#039;?&#039;:
      case &#039;*&#039;:
      case &#039;+&#039;:
      case &#039;@&#039;:
      case &#039;!&#039;:
        this.debug(&#039;%s\t%s %s %j &lt;-- stateChar&#039;, pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug(&#039;  in class&#039;)
          if (c === &#039;!&#039; &amp;&amp; i === classStart + 1) c = &#039;^&#039;
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug(&#039;call clearStateChar %j&#039;, stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn&#039;t a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case &#039;(&#039;:
        if (inClass) {
          re += &#039;(&#039;
          continue
        }

        if (!stateChar) {
          re += &#039;\\(&#039;
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === &#039;!&#039; ? &#039;(?:(?!(?:&#039; : &#039;(?:&#039;
        this.debug(&#039;plType %j %j&#039;, stateChar, re)
        stateChar = false
      continue

      case &#039;)&#039;:
        if (inClass || !patternListStack.length) {
          re += &#039;\\)&#039;
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:&lt;pattern&gt;)&lt;type&gt;
        re += pl.close
        if (pl.type === &#039;!&#039;) {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case &#039;|&#039;:
        if (inClass || !patternListStack.length || escaping) {
          re += &#039;\\|&#039;
          escaping = false
          continue
        }

        clearStateChar()
        re += &#039;|&#039;
      continue

      // these are mostly the same in regexp and glob
      case &#039;[&#039;:
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += &#039;\\&#039; + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case &#039;]&#039;:
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += &#039;\\&#039; + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // &quot;[z-a]&quot; is valid, equivalent to &quot;\[z-a\]&quot;
        // split where the last [ was, make sure we don&#039;t have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it&#039;s tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp(&#039;[&#039; + cs + &#039;]&#039;)
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + &#039;\\[&#039; + sp[0] + &#039;\\]&#039;
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn&#039;t consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          &amp;&amp; !(c === &#039;^&#039; &amp;&amp; inClass)) {
          re += &#039;\\&#039;
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + &#039;\\[&#039; + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug(&#039;setting tail&#039;, re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn&#039;t already escaped, so escape it.
        $2 = &#039;\\&#039;
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That&#039;s why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + &#039;|&#039;
    })

    this.debug(&#039;tail=%j\n   %s&#039;, tail, tail, pl, re)
    var t = pl.type === &#039;*&#039; ? star
      : pl.type === &#039;?&#039; ? qmark
      : &#039;\\&#039; + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + &#039;\\(&#039; + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += &#039;\\\\&#039;
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case &#039;[&#039;: case &#039;.&#039;: case &#039;(&#039;: addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like &#039;a.xyz.yz&#039; doesn&#039;t match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n &gt; -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // &quot;after&quot; the negated section.
    var openParensBefore = nlBefore.split(&#039;(&#039;).length - 1
    var cleanAfter = nlAfter
    for (i = 0; i &lt; openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, &#039;&#039;)
    }
    nlAfter = cleanAfter

    var dollar = &#039;&#039;
    if (nlAfter === &#039;&#039; &amp;&amp; isSub !== SUBPARSE) {
      dollar = &#039;$&#039;
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not &quot;&quot; at this point, then we need to make sure
  // it doesn&#039;t match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== &#039;&#039; &amp;&amp; hasMagic) {
    re = &#039;(?=.)&#039; + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it&#039;ll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? &#039;i&#039; : &#039;&#039;
  try {
    var regExp = new RegExp(&#039;^&#039; + re + &#039;$&#039;, flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can&#039;t match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it&#039;s not a /m regex.
    return new RegExp(&#039;$.&#039;)
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or &quot;**&quot;.
  //
  // It&#039;s better to use .match().  This function shouldn&#039;t
  // be used, really, but it&#039;s pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? &#039;i&#039; : &#039;&#039;

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === &#039;string&#039;) ? regExpEscape(p)
      : p._src
    }).join(&#039;\\\/&#039;)
  }).join(&#039;|&#039;)

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = &#039;^(?:&#039; + re + &#039;)$&#039;

  // can match anything, as long as it&#039;s not this.
  if (this.negate) re = &#039;^(?!&#039; + re + &#039;).*$&#039;

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull &amp;&amp; !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === &#039;undefined&#039;) partial = this.partial
  this.debug(&#039;match&#039;, f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === &#039;&#039;

  if (f === &#039;/&#039; &amp;&amp; partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== &#039;/&#039;) {
    f = f.split(path.sep).join(&#039;/&#039;)
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, &#039;split&#039;, f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, &#039;set&#039;, set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i &gt;= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i &lt; set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase &amp;&amp; pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn&#039;t get any hits.  this is success if it&#039;s a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;
// Partial means, if you run out of file before you run
// out of pattern, then that&#039;s fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug(&#039;matchOne&#039;,
    { &#039;this&#039;: this, file: file, pattern: pattern })

  this.debug(&#039;matchOne&#039;, file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
      ; fi++, pi++) {
    this.debug(&#039;matchOne loop&#039;)
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug(&#039;GLOBSTAR&#039;, [pattern, p, f])

      // &quot;**&quot;
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** &quot;swallows&quot; a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -&gt; no
      //       - matchOne(y/z/c, c) -&gt; no
      //       - matchOne(z/c, c) -&gt; no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug(&#039;** at the end&#039;)
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi &lt; fl; fi++) {
          if (file[fi] === &#039;.&#039; || file[fi] === &#039;..&#039; ||
            (!options.dot &amp;&amp; file[fi].charAt(0) === &#039;.&#039;)) return false
        }
        return true
      }

      // ok, let&#039;s see if we can swallow whatever we can.
      while (fr &lt; fl) {
        var swallowee = file[fr]

        this.debug(&#039;\nglobstar while&#039;, file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug(&#039;globstar found match!&#039;, fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can&#039;t swallow &quot;.&quot; or &quot;..&quot; ever.
          // can only swallow &quot;.foo&quot; when explicitly asked.
          if (swallowee === &#039;.&#039; || swallowee === &#039;..&#039; ||
            (!options.dot &amp;&amp; swallowee.charAt(0) === &#039;.&#039;)) {
            this.debug(&#039;dot detected!&#039;, file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug(&#039;globstar swallow a segment, and continue&#039;)
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can&#039;t say this is necessarily over.
      // If there&#039;s more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug(&#039;\n&gt;&gt;&gt; no match, partial?&#039;, file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === &#039;string&#039;) {
      hit = f === p
      this.debug(&#039;string match&#039;, p, f, hit)
    } else {
      hit = f.match(p)
      this.debug(&#039;pattern match&#039;, p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we&#039;ll get a final &quot;&quot;
  // at the end of the pattern.  This can only match a
  // corresponding &quot;&quot; at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn&#039;t have any more for it. But, a/b/ should *not*
  // match &quot;a/b/*&quot;, even though &quot;&quot; matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we&#039;re done.
  if (fi === fl &amp;&amp; pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we&#039;re doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we&#039;re on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) &amp;&amp; (file[fi] === &#039;&#039;)
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error(&#039;wtf?&#039;)
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, &#039;$1&#039;)
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &#039;\\$&amp;&#039;)
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
