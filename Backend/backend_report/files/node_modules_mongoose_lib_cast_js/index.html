<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules\mongoose\lib\cast.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules\mongoose\lib\cast.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">35.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">429</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">93.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">4.08</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

/*!
 * Module dependencies.
 */

const CastError = require(&#039;./error/cast&#039;);
const StrictModeError = require(&#039;./error/strict&#039;);
const Types = require(&#039;./schema/index&#039;);
const cast$expr = require(&#039;./helpers/query/cast$expr&#039;);
const castTextSearch = require(&#039;./schema/operators/text&#039;);
const get = require(&#039;./helpers/get&#039;);
const getSchemaDiscriminatorByValue = require(&#039;./helpers/discriminator/getSchemaDiscriminatorByValue&#039;);
const isOperator = require(&#039;./helpers/query/isOperator&#039;);
const util = require(&#039;util&#039;);
const isObject = require(&#039;./helpers/isObject&#039;);
const isMongooseObject = require(&#039;./helpers/isMongooseObject&#039;);
const utils = require(&#039;./utils&#039;);

const ALLOWED_GEOWITHIN_GEOJSON_TYPES = [&#039;Polygon&#039;, &#039;MultiPolygon&#039;];

/**
 * Handles internal casting for query filters.
 *
 * @param {Schema} schema
 * @param {Object} obj Object to cast
 * @param {Object} [options] the query options
 * @param {Boolean|&quot;throw&quot;} [options.strict] Wheter to enable all strict options
 * @param {Boolean|&quot;throw&quot;} [options.strictQuery] Enable strict Queries
 * @param {Boolean} [options.upsert]
 * @param {Query} [context] passed to setters
 * @api private
 */
module.exports = function cast(schema, obj, options, context) {
  if (Array.isArray(obj)) {
    throw new Error(&#039;Query filter must be an object, got an array &#039;, util.inspect(obj));
  }

  if (obj == null) {
    return obj;
  }

  if (schema != null &amp;&amp; schema.discriminators != null &amp;&amp; obj[schema.options.discriminatorKey] != null) {
    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;
  }

  const paths = Object.keys(obj);
  let i = paths.length;
  let _keys;
  let any$conditionals;
  let schematype;
  let nested;
  let path;
  let type;
  let val;

  options = options || {};

  while (i--) {
    path = paths[i];
    val = obj[path];

    if (path === &#039;$or&#039; || path === &#039;$nor&#039; || path === &#039;$and&#039;) {
      if (!Array.isArray(val)) {
        throw new CastError(&#039;Array&#039;, val, path);
      }
      for (let k = 0; k &lt; val.length; ++k) {
        if (val[k] == null || typeof val[k] !== &#039;object&#039;) {
          throw new CastError(&#039;Object&#039;, val[k], path + &#039;.&#039; + k);
        }
        const discriminatorValue = val[k][schema.options.discriminatorKey];
        if (discriminatorValue == null) {
          val[k] = cast(schema, val[k], options, context);
        } else {
          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);
          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);
        }
      }
    } else if (path === &#039;$where&#039;) {
      type = typeof val;

      if (type !== &#039;string&#039; &amp;&amp; type !== &#039;function&#039;) {
        throw new Error(&#039;Must have a string or function for $where&#039;);
      }

      if (type === &#039;function&#039;) {
        obj[path] = val.toString();
      }

      continue;
    } else if (path === &#039;$expr&#039;) {
      val = cast$expr(val, schema);
      continue;
    } else if (path === &#039;$elemMatch&#039;) {
      val = cast(schema, val, options, context);
    } else if (path === &#039;$text&#039;) {
      val = castTextSearch(val, path);
    } else {
      if (!schema) {
        // no casting for Mixed types
        continue;
      }

      schematype = schema.path(path);

      // Check for embedded discriminator paths
      if (!schematype) {
        const split = path.split(&#039;.&#039;);
        let j = split.length;
        while (j--) {
          const pathFirstHalf = split.slice(0, j).join(&#039;.&#039;);
          const pathLastHalf = split.slice(j).join(&#039;.&#039;);
          const _schematype = schema.path(pathFirstHalf);
          const discriminatorKey = _schematype &amp;&amp;
            _schematype.schema &amp;&amp;
            _schematype.schema.options &amp;&amp;
            _schematype.schema.options.discriminatorKey;

          // gh-6027: if we haven&#039;t found the schematype but this path is
          // underneath an embedded discriminator and the embedded discriminator
          // key is in the query, use the embedded discriminator schema
          if (_schematype != null &amp;&amp;
            (_schematype.schema &amp;&amp; _schematype.schema.discriminators) != null &amp;&amp;
            discriminatorKey != null &amp;&amp;
            pathLastHalf !== discriminatorKey) {
            const discriminatorVal = get(obj, pathFirstHalf + &#039;.&#039; + discriminatorKey);
            const discriminators = _schematype.schema.discriminators;
            if (typeof discriminatorVal === &#039;string&#039; &amp;&amp; discriminators[discriminatorVal] != null) {

              schematype = discriminators[discriminatorVal].path(pathLastHalf);
            } else if (discriminatorVal != null &amp;&amp;
              Object.keys(discriminatorVal).length === 1 &amp;&amp;
              Array.isArray(discriminatorVal.$in) &amp;&amp;
              discriminatorVal.$in.length === 1 &amp;&amp;
              typeof discriminatorVal.$in[0] === &#039;string&#039; &amp;&amp;
              discriminators[discriminatorVal.$in[0]] != null) {
              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);
            }
          }
        }
      }

      if (!schematype) {
        // Handle potential embedded array queries
        const split = path.split(&#039;.&#039;);
        let j = split.length;
        let pathFirstHalf;
        let pathLastHalf;
        let remainingConds;

        // Find the part of the var path that is a path of the Schema
        while (j--) {
          pathFirstHalf = split.slice(0, j).join(&#039;.&#039;);
          schematype = schema.path(pathFirstHalf);
          if (schematype) {
            break;
          }
        }

        // If a substring of the input path resolves to an actual real path...
        if (schematype) {
          // Apply the casting; similar code for $elemMatch in schema/array.js
          if (schematype.caster &amp;&amp; schematype.caster.schema) {
            remainingConds = {};
            pathLastHalf = split.slice(j).join(&#039;.&#039;);
            remainingConds[pathLastHalf] = val;

            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];
            if (ret === void 0) {
              delete obj[path];
            } else {
              obj[path] = ret;
            }
          } else {
            obj[path] = val;
          }
          continue;
        }

        if (isObject(val)) {
          // handle geo schemas that use object notation
          // { loc: { long: Number, lat: Number }

          let geo = &#039;&#039;;
          if (val.$near) {
            geo = &#039;$near&#039;;
          } else if (val.$nearSphere) {
            geo = &#039;$nearSphere&#039;;
          } else if (val.$within) {
            geo = &#039;$within&#039;;
          } else if (val.$geoIntersects) {
            geo = &#039;$geoIntersects&#039;;
          } else if (val.$geoWithin) {
            geo = &#039;$geoWithin&#039;;
          }

          if (geo) {
            const numbertype = new Types.Number(&#039;__QueryCasting__&#039;);
            let value = val[geo];

            if (val.$maxDistance != null) {
              val.$maxDistance = numbertype.castForQuery(
                null,
                val.$maxDistance,
                context
              );
            }
            if (val.$minDistance != null) {
              val.$minDistance = numbertype.castForQuery(
                null,
                val.$minDistance,
                context
              );
            }

            if (geo === &#039;$within&#039;) {
              const withinType = value.$center
                  || value.$centerSphere
                  || value.$box
                  || value.$polygon;

              if (!withinType) {
                throw new Error(&#039;Bad $within parameter: &#039; + JSON.stringify(val));
              }

              value = withinType;
            } else if (geo === &#039;$near&#039; &amp;&amp;
                typeof value.type === &#039;string&#039; &amp;&amp; Array.isArray(value.coordinates)) {
              // geojson; cast the coordinates
              value = value.coordinates;
            } else if ((geo === &#039;$near&#039; || geo === &#039;$nearSphere&#039; || geo === &#039;$geoIntersects&#039;) &amp;&amp;
                value.$geometry &amp;&amp; typeof value.$geometry.type === &#039;string&#039; &amp;&amp;
                Array.isArray(value.$geometry.coordinates)) {
              if (value.$maxDistance != null) {
                value.$maxDistance = numbertype.castForQuery(
                  null,
                  value.$maxDistance,
                  context
                );
              }
              if (value.$minDistance != null) {
                value.$minDistance = numbertype.castForQuery(
                  null,
                  value.$minDistance,
                  context
                );
              }
              if (isMongooseObject(value.$geometry)) {
                value.$geometry = value.$geometry.toObject({
                  transform: false,
                  virtuals: false
                });
              }
              value = value.$geometry.coordinates;
            } else if (geo === &#039;$geoWithin&#039;) {
              if (value.$geometry) {
                if (isMongooseObject(value.$geometry)) {
                  value.$geometry = value.$geometry.toObject({ virtuals: false });
                }
                const geoWithinType = value.$geometry.type;
                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {
                  throw new Error(&#039;Invalid geoJSON type for $geoWithin &quot;&#039; +
                    geoWithinType + &#039;&quot;, must be &quot;Polygon&quot; or &quot;MultiPolygon&quot;&#039;);
                }
                value = value.$geometry.coordinates;
              } else {
                value = value.$box || value.$polygon || value.$center ||
                  value.$centerSphere;
                if (isMongooseObject(value)) {
                  value = value.toObject({ virtuals: false });
                }
              }
            }

            _cast(value, numbertype, context);
            continue;
          }
        }

        if (schema.nested[path]) {
          continue;
        }

        const strict = &#039;strict&#039; in options ? options.strict : schema.options.strict;
        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);
        if (options.upsert &amp;&amp; strict) {
          if (strict === &#039;throw&#039;) {
            throw new StrictModeError(path);
          }
          throw new StrictModeError(path, &#039;Path &quot;&#039; + path + &#039;&quot; is not in &#039; +
            &#039;schema, strict mode is `true`, and upsert is `true`.&#039;);
        } if (strictQuery === &#039;throw&#039;) {
          throw new StrictModeError(path, &#039;Path &quot;&#039; + path + &#039;&quot; is not in &#039; +
            &#039;schema and strictQuery is \&#039;throw\&#039;.&#039;);
        } else if (strictQuery) {
          delete obj[path];
        }
      } else if (val == null) {
        continue;
      } else if (utils.isPOJO(val)) {
        any$conditionals = Object.keys(val).some(isOperator);

        if (!any$conditionals) {
          obj[path] = schematype.castForQuery(
            null,
            val,
            context
          );
        } else {
          const ks = Object.keys(val);
          let $cond;
          let k = ks.length;

          while (k--) {
            $cond = ks[k];
            nested = val[$cond];
            if ($cond === &#039;$elemMatch&#039;) {
              if (nested &amp;&amp; schematype != null &amp;&amp; schematype.schema != null) {
                cast(schematype.schema, nested, options, context);
              } else if (nested &amp;&amp; schematype != null &amp;&amp; schematype.$isMongooseArray) {
                if (utils.isPOJO(nested) &amp;&amp; nested.$not != null) {
                  cast(schema, nested, options, context);
                } else {
                  val[$cond] = schematype.castForQuery(
                    $cond,
                    nested,
                    context
                  );
                }
              }
            } else if ($cond === &#039;$not&#039;) {
              if (nested &amp;&amp; schematype) {
                _keys = Object.keys(nested);
                if (_keys.length &amp;&amp; isOperator(_keys[0])) {
                  for (const key in nested) {
                    nested[key] = schematype.castForQuery(
                      key,
                      nested[key],
                      context
                    );
                  }
                } else {
                  val[$cond] = schematype.castForQuery(
                    $cond,
                    nested,
                    context
                  );
                }
                continue;
              }
            } else {
              val[$cond] = schematype.castForQuery(
                $cond,
                nested,
                context
              );
            }

          }
        }
      } else if (Array.isArray(val) &amp;&amp; [&#039;Buffer&#039;, &#039;Array&#039;].indexOf(schematype.instance) === -1) {
        const casted = [];
        const valuesArray = val;

        for (const _val of valuesArray) {
          casted.push(schematype.castForQuery(
            null,
            _val,
            context
          ));
        }

        obj[path] = { $in: casted };
      } else {
        obj[path] = schematype.castForQuery(
          null,
          val,
          context
        );
      }
    }
  }

  return obj;
};

function _cast(val, numbertype, context) {
  if (Array.isArray(val)) {
    val.forEach(function(item, i) {
      if (Array.isArray(item) || isObject(item)) {
        return _cast(item, numbertype, context);
      }
      val[i] = numbertype.castForQuery(null, item, context);
    });
  } else {
    const nearKeys = Object.keys(val);
    let nearLen = nearKeys.length;
    while (nearLen--) {
      const nkey = nearKeys[nearLen];
      const item = val[nkey];
      if (Array.isArray(item) || isObject(item)) {
        _cast(item, numbertype, context);
        val[nkey] = item;
      } else {
        val[nkey] = numbertype.castForQuery({ val: item, context: context });
      }
    }
  }
}

function getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {
  if (&#039;strictQuery&#039; in queryOptions) {
    return queryOptions.strictQuery;
  }
  if (&#039;strictQuery&#039; in schemaUserProvidedOptions) {
    return schemaUserProvidedOptions.strictQuery;
  }
  const mongooseOptions = context &amp;&amp;
    context.mongooseCollection &amp;&amp;
    context.mongooseCollection.conn &amp;&amp;
    context.mongooseCollection.conn.base &amp;&amp;
    context.mongooseCollection.conn.base.options;
  if (mongooseOptions) {
    if (&#039;strictQuery&#039; in mongooseOptions) {
      return mongooseOptions.strictQuery;
    }
  }
  return schemaOptions.strictQuery;
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
