<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules\express\lib\response.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules\express\lib\response.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1169</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">83.40</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.99</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

&#039;use strict&#039;;

/**
 * Module dependencies.
 * @private
 */

var Buffer = require(&#039;safe-buffer&#039;).Buffer
var contentDisposition = require(&#039;content-disposition&#039;);
var createError = require(&#039;http-errors&#039;)
var deprecate = require(&#039;depd&#039;)(&#039;express&#039;);
var encodeUrl = require(&#039;encodeurl&#039;);
var escapeHtml = require(&#039;escape-html&#039;);
var http = require(&#039;http&#039;);
var isAbsolute = require(&#039;./utils&#039;).isAbsolute;
var onFinished = require(&#039;on-finished&#039;);
var path = require(&#039;path&#039;);
var statuses = require(&#039;statuses&#039;)
var merge = require(&#039;utils-merge&#039;);
var sign = require(&#039;cookie-signature&#039;).sign;
var normalizeType = require(&#039;./utils&#039;).normalizeType;
var normalizeTypes = require(&#039;./utils&#039;).normalizeTypes;
var setCharset = require(&#039;./utils&#039;).setCharset;
var cookie = require(&#039;cookie&#039;);
var send = require(&#039;send&#039;);
var extname = path.extname;
var mime = send.mime;
var resolve = path.resolve;
var vary = require(&#039;vary&#039;);

/**
 * Response prototype.
 * @public
 */

var res = Object.create(http.ServerResponse.prototype)

/**
 * Module exports.
 * @public
 */

module.exports = res

/**
 * Module variables.
 * @private
 */

var charsetRegExp = /;\s*charset\s*=/;

/**
 * Set status `code`.
 *
 * @param {Number} code
 * @return {ServerResponse}
 * @public
 */

res.status = function status(code) {
  if ((typeof code === &#039;string&#039; || Math.floor(code) !== code) &amp;&amp; code &gt; 99 &amp;&amp; code &lt; 1000) {
    deprecate(&#039;res.status(&#039; + JSON.stringify(code) + &#039;): use res.status(&#039; + Math.floor(code) + &#039;) instead&#039;)
  }
  this.statusCode = code;
  return this;
};

/**
 * Set Link header field with the given `links`.
 *
 * Examples:
 *
 *    res.links({
 *      next: &#039;http://api.example.com/users?page=2&#039;,
 *      last: &#039;http://api.example.com/users?page=5&#039;
 *    });
 *
 * @param {Object} links
 * @return {ServerResponse}
 * @public
 */

res.links = function(links){
  var link = this.get(&#039;Link&#039;) || &#039;&#039;;
  if (link) link += &#039;, &#039;;
  return this.set(&#039;Link&#039;, link + Object.keys(links).map(function(rel){
    return &#039;&lt;&#039; + links[rel] + &#039;&gt;; rel=&quot;&#039; + rel + &#039;&quot;&#039;;
  }).join(&#039;, &#039;));
};

/**
 * Send a response.
 *
 * Examples:
 *
 *     res.send(Buffer.from(&#039;wahoo&#039;));
 *     res.send({ some: &#039;json&#039; });
 *     res.send(&#039;&lt;p&gt;some html&lt;/p&gt;&#039;);
 *
 * @param {string|number|boolean|object|Buffer} body
 * @public
 */

res.send = function send(body) {
  var chunk = body;
  var encoding;
  var req = this.req;
  var type;

  // settings
  var app = this.app;

  // allow status / body
  if (arguments.length === 2) {
    // res.send(body, status) backwards compat
    if (typeof arguments[0] !== &#039;number&#039; &amp;&amp; typeof arguments[1] === &#039;number&#039;) {
      deprecate(&#039;res.send(body, status): Use res.status(status).send(body) instead&#039;);
      this.statusCode = arguments[1];
    } else {
      deprecate(&#039;res.send(status, body): Use res.status(status).send(body) instead&#039;);
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }

  // disambiguate res.send(status) and res.send(status, num)
  if (typeof chunk === &#039;number&#039; &amp;&amp; arguments.length === 1) {
    // res.send(status) will set status message as text string
    if (!this.get(&#039;Content-Type&#039;)) {
      this.type(&#039;txt&#039;);
    }

    deprecate(&#039;res.send(status): Use res.sendStatus(status) instead&#039;);
    this.statusCode = chunk;
    chunk = statuses.message[chunk]
  }

  switch (typeof chunk) {
    // string defaulting to html
    case &#039;string&#039;:
      if (!this.get(&#039;Content-Type&#039;)) {
        this.type(&#039;html&#039;);
      }
      break;
    case &#039;boolean&#039;:
    case &#039;number&#039;:
    case &#039;object&#039;:
      if (chunk === null) {
        chunk = &#039;&#039;;
      } else if (Buffer.isBuffer(chunk)) {
        if (!this.get(&#039;Content-Type&#039;)) {
          this.type(&#039;bin&#039;);
        }
      } else {
        return this.json(chunk);
      }
      break;
  }

  // write strings in utf-8
  if (typeof chunk === &#039;string&#039;) {
    encoding = &#039;utf8&#039;;
    type = this.get(&#039;Content-Type&#039;);

    // reflect this in content-type
    if (typeof type === &#039;string&#039;) {
      this.set(&#039;Content-Type&#039;, setCharset(type, &#039;utf-8&#039;));
    }
  }

  // determine if ETag should be generated
  var etagFn = app.get(&#039;etag fn&#039;)
  var generateETag = !this.get(&#039;ETag&#039;) &amp;&amp; typeof etagFn === &#039;function&#039;

  // populate Content-Length
  var len
  if (chunk !== undefined) {
    if (Buffer.isBuffer(chunk)) {
      // get length of Buffer
      len = chunk.length
    } else if (!generateETag &amp;&amp; chunk.length &lt; 1000) {
      // just calculate length when no ETag + small chunk
      len = Buffer.byteLength(chunk, encoding)
    } else {
      // convert chunk to Buffer and calculate
      chunk = Buffer.from(chunk, encoding)
      encoding = undefined;
      len = chunk.length
    }

    this.set(&#039;Content-Length&#039;, len);
  }

  // populate ETag
  var etag;
  if (generateETag &amp;&amp; len !== undefined) {
    if ((etag = etagFn(chunk, encoding))) {
      this.set(&#039;ETag&#039;, etag);
    }
  }

  // freshness
  if (req.fresh) this.statusCode = 304;

  // strip irrelevant headers
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader(&#039;Content-Type&#039;);
    this.removeHeader(&#039;Content-Length&#039;);
    this.removeHeader(&#039;Transfer-Encoding&#039;);
    chunk = &#039;&#039;;
  }

  // alter headers for 205
  if (this.statusCode === 205) {
    this.set(&#039;Content-Length&#039;, &#039;0&#039;)
    this.removeHeader(&#039;Transfer-Encoding&#039;)
    chunk = &#039;&#039;
  }

  if (req.method === &#039;HEAD&#039;) {
    // skip body for HEAD
    this.end();
  } else {
    // respond
    this.end(chunk, encoding);
  }

  return this;
};

/**
 * Send JSON response.
 *
 * Examples:
 *
 *     res.json(null);
 *     res.json({ user: &#039;tj&#039; });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.json = function json(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.json(body, status) backwards compat
    if (typeof arguments[1] === &#039;number&#039;) {
      deprecate(&#039;res.json(obj, status): Use res.status(status).json(obj) instead&#039;);
      this.statusCode = arguments[1];
    } else {
      deprecate(&#039;res.json(status, obj): Use res.status(status).json(obj) instead&#039;);
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get(&#039;json escape&#039;)
  var replacer = app.get(&#039;json replacer&#039;);
  var spaces = app.get(&#039;json spaces&#039;);
  var body = stringify(val, replacer, spaces, escape)

  // content-type
  if (!this.get(&#039;Content-Type&#039;)) {
    this.set(&#039;Content-Type&#039;, &#039;application/json&#039;);
  }

  return this.send(body);
};

/**
 * Send JSON response with JSONP callback support.
 *
 * Examples:
 *
 *     res.jsonp(null);
 *     res.jsonp({ user: &#039;tj&#039; });
 *
 * @param {string|number|boolean|object} obj
 * @public
 */

res.jsonp = function jsonp(obj) {
  var val = obj;

  // allow status / body
  if (arguments.length === 2) {
    // res.jsonp(body, status) backwards compat
    if (typeof arguments[1] === &#039;number&#039;) {
      deprecate(&#039;res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead&#039;);
      this.statusCode = arguments[1];
    } else {
      deprecate(&#039;res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead&#039;);
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }

  // settings
  var app = this.app;
  var escape = app.get(&#039;json escape&#039;)
  var replacer = app.get(&#039;json replacer&#039;);
  var spaces = app.get(&#039;json spaces&#039;);
  var body = stringify(val, replacer, spaces, escape)
  var callback = this.req.query[app.get(&#039;jsonp callback name&#039;)];

  // content-type
  if (!this.get(&#039;Content-Type&#039;)) {
    this.set(&#039;X-Content-Type-Options&#039;, &#039;nosniff&#039;);
    this.set(&#039;Content-Type&#039;, &#039;application/json&#039;);
  }

  // fixup callback
  if (Array.isArray(callback)) {
    callback = callback[0];
  }

  // jsonp
  if (typeof callback === &#039;string&#039; &amp;&amp; callback.length !== 0) {
    this.set(&#039;X-Content-Type-Options&#039;, &#039;nosniff&#039;);
    this.set(&#039;Content-Type&#039;, &#039;text/javascript&#039;);

    // restrict callback charset
    callback = callback.replace(/[^\[\]\w$.]/g, &#039;&#039;);

    if (body === undefined) {
      // empty argument
      body = &#039;&#039;
    } else if (typeof body === &#039;string&#039;) {
      // replace chars not allowed in JavaScript that are in JSON
      body = body
        .replace(/\u2028/g, &#039;\\u2028&#039;)
        .replace(/\u2029/g, &#039;\\u2029&#039;)
    }

    // the /**/ is a specific security mitigation for &quot;Rosetta Flash JSONP abuse&quot;
    // the typeof check is just to reduce client error noise
    body = &#039;/**/ typeof &#039; + callback + &#039; === \&#039;function\&#039; &amp;&amp; &#039; + callback + &#039;(&#039; + body + &#039;);&#039;;
  }

  return this.send(body);
};

/**
 * Send given HTTP status code.
 *
 * Sets the response status to `statusCode` and the body of the
 * response to the standard description from node&#039;s http.STATUS_CODES
 * or the statusCode number if no description.
 *
 * Examples:
 *
 *     res.sendStatus(200);
 *
 * @param {number} statusCode
 * @public
 */

res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode)

  this.statusCode = statusCode;
  this.type(&#039;txt&#039;);

  return this.send(body);
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `&quot;allow&quot;` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendFile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendFile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get(&#039;/user/:uid/photos/:file&#039;, function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendFile(&#039;/uploads/&#039; + uid + &#039;/&#039; + file);
 *         } else {
 *           res.send(403, &#039;Sorry! you cant see that.&#039;);
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendFile = function sendFile(path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  if (!path) {
    throw new TypeError(&#039;path argument is required to res.sendFile&#039;);
  }

  if (typeof path !== &#039;string&#039;) {
    throw new TypeError(&#039;path must be a string to res.sendFile&#039;)
  }

  // support function as second arg
  if (typeof options === &#039;function&#039;) {
    done = options;
    opts = {};
  }

  if (!opts.root &amp;&amp; !isAbsolute(path)) {
    throw new TypeError(&#039;path must be absolute or specify root to res.sendFile&#039;);
  }

  // create file stream
  var pathname = encodeURI(path);
  var file = send(req, pathname, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err &amp;&amp; err.code === &#039;EISDIR&#039;) return next();

    // next() all but write errors
    if (err &amp;&amp; err.code !== &#039;ECONNABORTED&#039; &amp;&amp; err.syscall !== &#039;write&#039;) {
      next(err);
    }
  });
};

/**
 * Transfer the file at the given `path`.
 *
 * Automatically sets the _Content-Type_ response header field.
 * The callback `callback(err)` is invoked when the transfer is complete
 * or when an error occurs. Be sure to check `res.headersSent`
 * if you wish to attempt responding, as the header and some data
 * may have already been transferred.
 *
 * Options:
 *
 *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
 *   - `root`     root directory for relative filenames
 *   - `headers`  object of headers to serve with file
 *   - `dotfiles` serve dotfiles, defaulting to false; can be `&quot;allow&quot;` to send them
 *
 * Other options are passed along to `send`.
 *
 * Examples:
 *
 *  The following example illustrates how `res.sendfile()` may
 *  be used as an alternative for the `static()` middleware for
 *  dynamic situations. The code backing `res.sendfile()` is actually
 *  the same code, so HTTP cache support etc is identical.
 *
 *     app.get(&#039;/user/:uid/photos/:file&#039;, function(req, res){
 *       var uid = req.params.uid
 *         , file = req.params.file;
 *
 *       req.user.mayViewFilesFrom(uid, function(yes){
 *         if (yes) {
 *           res.sendfile(&#039;/uploads/&#039; + uid + &#039;/&#039; + file);
 *         } else {
 *           res.send(403, &#039;Sorry! you cant see that.&#039;);
 *         }
 *       });
 *     });
 *
 * @public
 */

res.sendfile = function (path, options, callback) {
  var done = callback;
  var req = this.req;
  var res = this;
  var next = req.next;
  var opts = options || {};

  // support function as second arg
  if (typeof options === &#039;function&#039;) {
    done = options;
    opts = {};
  }

  // create file stream
  var file = send(req, path, opts);

  // transfer
  sendfile(res, file, opts, function (err) {
    if (done) return done(err);
    if (err &amp;&amp; err.code === &#039;EISDIR&#039;) return next();

    // next() all but write errors
    if (err &amp;&amp; err.code !== &#039;ECONNABORTED&#039; &amp;&amp; err.syscall !== &#039;write&#039;) {
      next(err);
    }
  });
};

res.sendfile = deprecate.function(res.sendfile,
  &#039;res.sendfile: Use res.sendFile instead&#039;);

/**
 * Transfer the file at the given `path` as an attachment.
 *
 * Optionally providing an alternate attachment `filename`,
 * and optional callback `callback(err)`. The callback is invoked
 * when the data transfer is complete, or when an error has
 * occurred. Be sure to check `res.headersSent` if you plan to respond.
 *
 * Optionally providing an `options` object to use with `res.sendFile()`.
 * This function will set the `Content-Disposition` header, overriding
 * any `Content-Disposition` header passed as header options in order
 * to set the attachment and filename.
 *
 * This method uses `res.sendFile()`.
 *
 * @public
 */

res.download = function download (path, filename, options, callback) {
  var done = callback;
  var name = filename;
  var opts = options || null

  // support function as second or third arg
  if (typeof filename === &#039;function&#039;) {
    done = filename;
    name = null;
    opts = null
  } else if (typeof options === &#039;function&#039;) {
    done = options
    opts = null
  }

  // support optional filename, where options may be in it&#039;s place
  if (typeof filename === &#039;object&#039; &amp;&amp;
    (typeof options === &#039;function&#039; || options === undefined)) {
    name = null
    opts = filename
  }

  // set Content-Disposition when file is sent
  var headers = {
    &#039;Content-Disposition&#039;: contentDisposition(name || path)
  };

  // merge user-provided headers
  if (opts &amp;&amp; opts.headers) {
    var keys = Object.keys(opts.headers)
    for (var i = 0; i &lt; keys.length; i++) {
      var key = keys[i]
      if (key.toLowerCase() !== &#039;content-disposition&#039;) {
        headers[key] = opts.headers[key]
      }
    }
  }

  // merge user-provided options
  opts = Object.create(opts)
  opts.headers = headers

  // Resolve the full path for sendFile
  var fullPath = !opts.root
    ? resolve(path)
    : path

  // send file
  return this.sendFile(fullPath, opts, done)
};

/**
 * Set _Content-Type_ response header with `type` through `mime.lookup()`
 * when it does not contain &quot;/&quot;, or set the Content-Type to `type` otherwise.
 *
 * Examples:
 *
 *     res.type(&#039;.html&#039;);
 *     res.type(&#039;html&#039;);
 *     res.type(&#039;json&#039;);
 *     res.type(&#039;application/json&#039;);
 *     res.type(&#039;png&#039;);
 *
 * @param {String} type
 * @return {ServerResponse} for chaining
 * @public
 */

res.contentType =
res.type = function contentType(type) {
  var ct = type.indexOf(&#039;/&#039;) === -1
    ? mime.lookup(type)
    : type;

  return this.set(&#039;Content-Type&#039;, ct);
};

/**
 * Respond to the Acceptable formats using an `obj`
 * of mime-type callbacks.
 *
 * This method uses `req.accepted`, an array of
 * acceptable types ordered by their quality values.
 * When &quot;Accept&quot; is not present the _first_ callback
 * is invoked, otherwise the first match is used. When
 * no match is performed the server responds with
 * 406 &quot;Not Acceptable&quot;.
 *
 * Content-Type is set for you, however if you choose
 * you may alter this within the callback using `res.type()`
 * or `res.set(&#039;Content-Type&#039;, ...)`.
 *
 *    res.format({
 *      &#039;text/plain&#039;: function(){
 *        res.send(&#039;hey&#039;);
 *      },
 *
 *      &#039;text/html&#039;: function(){
 *        res.send(&#039;&lt;p&gt;hey&lt;/p&gt;&#039;);
 *      },
 *
 *      &#039;application/json&#039;: function () {
 *        res.send({ message: &#039;hey&#039; });
 *      }
 *    });
 *
 * In addition to canonicalized MIME types you may
 * also use extnames mapped to these types:
 *
 *    res.format({
 *      text: function(){
 *        res.send(&#039;hey&#039;);
 *      },
 *
 *      html: function(){
 *        res.send(&#039;&lt;p&gt;hey&lt;/p&gt;&#039;);
 *      },
 *
 *      json: function(){
 *        res.send({ message: &#039;hey&#039; });
 *      }
 *    });
 *
 * By default Express passes an `Error`
 * with a `.status` of 406 to `next(err)`
 * if a match is not made. If you provide
 * a `.default` callback it will be invoked
 * instead.
 *
 * @param {Object} obj
 * @return {ServerResponse} for chaining
 * @public
 */

res.format = function(obj){
  var req = this.req;
  var next = req.next;

  var keys = Object.keys(obj)
    .filter(function (v) { return v !== &#039;default&#039; })

  var key = keys.length &gt; 0
    ? req.accepts(keys)
    : false;

  this.vary(&quot;Accept&quot;);

  if (key) {
    this.set(&#039;Content-Type&#039;, normalizeType(key).value);
    obj[key](req, this, next);
  } else if (obj.default) {
    obj.default(req, this, next)
  } else {
    next(createError(406, {
      types: normalizeTypes(keys).map(function (o) { return o.value })
    }))
  }

  return this;
};

/**
 * Set _Content-Disposition_ header to _attachment_ with optional `filename`.
 *
 * @param {String} filename
 * @return {ServerResponse}
 * @public
 */

res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }

  this.set(&#039;Content-Disposition&#039;, contentDisposition(filename));

  return this;
};

/**
 * Append additional header `field` with value `val`.
 *
 * Example:
 *
 *    res.append(&#039;Link&#039;, [&#039;&lt;http://localhost/&gt;&#039;, &#039;&lt;http://localhost:3000/&gt;&#039;]);
 *    res.append(&#039;Set-Cookie&#039;, &#039;foo=bar; Path=/; HttpOnly&#039;);
 *    res.append(&#039;Warning&#039;, &#039;199 Miscellaneous warning&#039;);
 *
 * @param {String} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.append = function append(field, val) {
  var prev = this.get(field);
  var value = val;

  if (prev) {
    // concat the new and prev vals
    value = Array.isArray(prev) ? prev.concat(val)
      : Array.isArray(val) ? [prev].concat(val)
        : [prev, val]
  }

  return this.set(field, value);
};

/**
 * Set header `field` to `val`, or pass
 * an object of header fields.
 *
 * Examples:
 *
 *    res.set(&#039;Foo&#039;, [&#039;bar&#039;, &#039;baz&#039;]);
 *    res.set(&#039;Accept&#039;, &#039;application/json&#039;);
 *    res.set({ Accept: &#039;text/plain&#039;, &#039;X-API-Key&#039;: &#039;tobi&#039; });
 *
 * Aliased as `res.header()`.
 *
 * @param {String|Object} field
 * @param {String|Array} val
 * @return {ServerResponse} for chaining
 * @public
 */

res.set =
res.header = function header(field, val) {
  if (arguments.length === 2) {
    var value = Array.isArray(val)
      ? val.map(String)
      : String(val);

    // add charset to content-type
    if (field.toLowerCase() === &#039;content-type&#039;) {
      if (Array.isArray(value)) {
        throw new TypeError(&#039;Content-Type cannot be set to an Array&#039;);
      }
      if (!charsetRegExp.test(value)) {
        var charset = mime.charsets.lookup(value.split(&#039;;&#039;)[0]);
        if (charset) value += &#039;; charset=&#039; + charset.toLowerCase();
      }
    }

    this.setHeader(field, value);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};

/**
 * Get value for header `field`.
 *
 * @param {String} field
 * @return {String}
 * @public
 */

res.get = function(field){
  return this.getHeader(field);
};

/**
 * Clear cookie `name`.
 *
 * @param {String} name
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.clearCookie = function clearCookie(name, options) {
  var opts = merge({ expires: new Date(1), path: &#039;/&#039; }, options);

  return this.cookie(name, &#039;&#039;, opts);
};

/**
 * Set cookie `name` to `value`, with the given `options`.
 *
 * Options:
 *
 *    - `maxAge`   max-age in milliseconds, converted to `expires`
 *    - `signed`   sign the cookie
 *    - `path`     defaults to &quot;/&quot;
 *
 * Examples:
 *
 *    // &quot;Remember Me&quot; for 15 minutes
 *    res.cookie(&#039;rememberme&#039;, &#039;1&#039;, { expires: new Date(Date.now() + 900000), httpOnly: true });
 *
 *    // same as above
 *    res.cookie(&#039;rememberme&#039;, &#039;1&#039;, { maxAge: 900000, httpOnly: true })
 *
 * @param {String} name
 * @param {String|Object} value
 * @param {Object} [options]
 * @return {ServerResponse} for chaining
 * @public
 */

res.cookie = function (name, value, options) {
  var opts = merge({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;

  if (signed &amp;&amp; !secret) {
    throw new Error(&#039;cookieParser(&quot;secret&quot;) required for signed cookies&#039;);
  }

  var val = typeof value === &#039;object&#039;
    ? &#039;j:&#039; + JSON.stringify(value)
    : String(value);

  if (signed) {
    val = &#039;s:&#039; + sign(val, secret);
  }

  if (opts.maxAge != null) {
    var maxAge = opts.maxAge - 0

    if (!isNaN(maxAge)) {
      opts.expires = new Date(Date.now() + maxAge)
      opts.maxAge = Math.floor(maxAge / 1000)
    }
  }

  if (opts.path == null) {
    opts.path = &#039;/&#039;;
  }

  this.append(&#039;Set-Cookie&#039;, cookie.serialize(name, String(val), opts));

  return this;
};

/**
 * Set the location header to `url`.
 *
 * The given `url` can also be &quot;back&quot;, which redirects
 * to the _Referrer_ or _Referer_ headers or &quot;/&quot;.
 *
 * Examples:
 *
 *    res.location(&#039;/foo/bar&#039;).;
 *    res.location(&#039;http://example.com&#039;);
 *    res.location(&#039;../login&#039;);
 *
 * @param {String} url
 * @return {ServerResponse} for chaining
 * @public
 */

res.location = function location(url) {
  var loc = url;

  // &quot;back&quot; is an alias for the referrer
  if (url === &#039;back&#039;) {
    loc = this.req.get(&#039;Referrer&#039;) || &#039;/&#039;;
  }

  // set location
  return this.set(&#039;Location&#039;, encodeUrl(loc));
};

/**
 * Redirect to the given `url` with optional response `status`
 * defaulting to 302.
 *
 * The resulting `url` is determined by `res.location()`, so
 * it will play nicely with mounted apps, relative paths,
 * `&quot;back&quot;` etc.
 *
 * Examples:
 *
 *    res.redirect(&#039;/foo/bar&#039;);
 *    res.redirect(&#039;http://example.com&#039;);
 *    res.redirect(301, &#039;http://example.com&#039;);
 *    res.redirect(&#039;../login&#039;); // /blog/post/1 -&gt; /blog/login
 *
 * @public
 */

res.redirect = function redirect(url) {
  var address = url;
  var body;
  var status = 302;

  // allow status / url
  if (arguments.length === 2) {
    if (typeof arguments[0] === &#039;number&#039;) {
      status = arguments[0];
      address = arguments[1];
    } else {
      deprecate(&#039;res.redirect(url, status): Use res.redirect(status, url) instead&#039;);
      status = arguments[1];
    }
  }

  // Set location header
  address = this.location(address).get(&#039;Location&#039;);

  // Support text/{plain,html} by default
  this.format({
    text: function(){
      body = statuses.message[status] + &#039;. Redirecting to &#039; + address
    },

    html: function(){
      var u = escapeHtml(address);
      body = &#039;&lt;p&gt;&#039; + statuses.message[status] + &#039;. Redirecting to &lt;a href=&quot;&#039; + u + &#039;&quot;&gt;&#039; + u + &#039;&lt;/a&gt;&lt;/p&gt;&#039;
    },

    default: function(){
      body = &#039;&#039;;
    }
  });

  // Respond
  this.statusCode = status;
  this.set(&#039;Content-Length&#039;, Buffer.byteLength(body));

  if (this.req.method === &#039;HEAD&#039;) {
    this.end();
  } else {
    this.end(body);
  }
};

/**
 * Add `field` to Vary. If already present in the Vary set, then
 * this call is simply ignored.
 *
 * @param {Array|String} field
 * @return {ServerResponse} for chaining
 * @public
 */

res.vary = function(field){
  // checks for back-compat
  if (!field || (Array.isArray(field) &amp;&amp; !field.length)) {
    deprecate(&#039;res.vary(): Provide a field name&#039;);
    return this;
  }

  vary(this, field);

  return this;
};

/**
 * Render `view` with the given `options` and optional callback `fn`.
 * When a callback function is given a response will _not_ be made
 * automatically, otherwise a response of _200_ and _text/html_ is given.
 *
 * Options:
 *
 *  - `cache`     boolean hinting to the engine it should cache
 *  - `filename`  filename of the view being rendered
 *
 * @public
 */

res.render = function render(view, options, callback) {
  var app = this.req.app;
  var done = callback;
  var opts = options || {};
  var req = this.req;
  var self = this;

  // support callback function as second arg
  if (typeof options === &#039;function&#039;) {
    done = options;
    opts = {};
  }

  // merge res.locals
  opts._locals = self.locals;

  // default callback to respond
  done = done || function (err, str) {
    if (err) return req.next(err);
    self.send(str);
  };

  // render
  app.render(view, opts, done);
};

// pipe the send file stream
function sendfile(res, file, options, callback) {
  var done = false;
  var streaming;

  // request aborted
  function onaborted() {
    if (done) return;
    done = true;

    var err = new Error(&#039;Request aborted&#039;);
    err.code = &#039;ECONNABORTED&#039;;
    callback(err);
  }

  // directory
  function ondirectory() {
    if (done) return;
    done = true;

    var err = new Error(&#039;EISDIR, read&#039;);
    err.code = &#039;EISDIR&#039;;
    callback(err);
  }

  // errors
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }

  // ended
  function onend() {
    if (done) return;
    done = true;
    callback();
  }

  // file
  function onfile() {
    streaming = false;
  }

  // finished
  function onfinish(err) {
    if (err &amp;&amp; err.code === &#039;ECONNRESET&#039;) return onaborted();
    if (err) return onerror(err);
    if (done) return;

    setImmediate(function () {
      if (streaming !== false &amp;&amp; !done) {
        onaborted();
        return;
      }

      if (done) return;
      done = true;
      callback();
    });
  }

  // streaming
  function onstream() {
    streaming = true;
  }

  file.on(&#039;directory&#039;, ondirectory);
  file.on(&#039;end&#039;, onend);
  file.on(&#039;error&#039;, onerror);
  file.on(&#039;file&#039;, onfile);
  file.on(&#039;stream&#039;, onstream);
  onFinished(res, onfinish);

  if (options.headers) {
    // set headers on successful transfer
    file.on(&#039;headers&#039;, function headers(res) {
      var obj = options.headers;
      var keys = Object.keys(obj);

      for (var i = 0; i &lt; keys.length; i++) {
        var k = keys[i];
        res.setHeader(k, obj[k]);
      }
    });
  }

  // pipe
  file.pipe(res);
}

/**
 * Stringify JSON, like JSON.stringify, but v8 optimized, with the
 * ability to escape characters that can trigger HTML sniffing.
 *
 * @param {*} value
 * @param {function} replacer
 * @param {number} spaces
 * @param {boolean} escape
 * @returns {string}
 * @private
 */

function stringify (value, replacer, spaces, escape) {
  // v8 checks arguments.length for optimizing simple call
  // https://bugs.chromium.org/p/v8/issues/detail?id=4730
  var json = replacer || spaces
    ? JSON.stringify(value, replacer, spaces)
    : JSON.stringify(value);

  if (escape &amp;&amp; typeof json === &#039;string&#039;) {
    json = json.replace(/[&lt;&gt;&amp;]/g, function (c) {
      switch (c.charCodeAt(0)) {
        case 0x3c:
          return &#039;\\u003c&#039;
        case 0x3e:
          return &#039;\\u003e&#039;
        case 0x26:
          return &#039;\\u0026&#039;
        /* istanbul ignore next: unreachable default */
        default:
          return c
      }
    })
  }

  return json
}</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
